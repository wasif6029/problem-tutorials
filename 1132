
///Approach

/*******************************************
 Algorithm Used : Matrix Exponentiation
 
 
 
 
 As the value of n can be very high , linear loop is not an option . If we can somehow reduce the O(n) iteration to add all the values , we can find the sum .
 
 
 
 
 General Idea:
    f(p) = 1^k + 2^k + 3^k + ... + p^k
    
    this series can be written as :
        f(p) = f(p-1) + p^k
        
    Again from binomial expansion 
        (1+p)^k = kC0*p^0 + kC1p61 + kC2p^2 + ... + kCkp^k [as the maximum value of K is only 50, it won't bother us so much]
        
    Now,
        f(p+1) = f(p) + (1+p)^k

    We can solve this reccurrance relation very fast [O(log n * (matrix dimention)^3)] by using matrix exponentiation . 
    
    
    
    
        
 Idea of matrix exponentiation :
 
    If you don't have much idea on matrix exponentiation , I prefer you learn it first
    
    Some good resources to learn Matrix Exponentiation :
        blogs : 
            * http://zobayer.blogspot.com/2010/11/matrix-exponentiation.html
            * https://codeforces.com/blog/entry/67776
        
        Video Tutorials :
            * https://www.youtube.com/watch?v=QcT5T-46iFA (BACS)
            * https://www.youtube.com/watch?v=eMXNWcbw75E (Errichto)
            * https://www.youtube.com/watch?v=d8xB9jgEu-A (COdeNCode)
            * https://www.youtube.com/watch?v=EEb6JP3NXBI (Gaurav Sen)
    
    
                 BASE MATRIX                                                        HELPER_MATRIX           RESULTANT_MATRIX
    
    | 1     kC0         kC1         kC2         ...   kCk           |               | f(x)      |           | f(x+1)      |
    | 0     kC0         kC1         kC2         ...   kCk           |               | (x^k)     |           | (x+1)^k     |
    | 0     0           (k-1)C0     (k-1)C2     ...   (k-1)C(k-1)   |       *       | (x^(k-1)) |     =     | (x+1)^(k-1) |
    .
    .
    .
    | 0     0           0           0           ...   0C0           |               | x^0       |           | (x+1)^0     | 
    
    (Each row of the resultant matrix indicates the next states vale of that row of the helper matrix)
    
    We fill up our base matrix A and the helper matrix H accordingly .
    
    The first row of our resultant matrix will store the value of answer .
    
    There is , however, one little thing to note . We have to find the value mod 2^32 . Now the modulo operation takes a lot of time , But if you look closely you'll see we 2^32 is nothing but the max value of unsigned integer . Again in this problem occurance negative number is impossible. So if we use unsigned integer in multiplication it will give us the mod value
    (https://stackoverflow.com/questions/16056758/c-c-unsigned-integer-overflow) It will save time and prevent Time limit Error .
    
******************************************/



///C++ Code

#include<bits/stdc++.h>
using namespace std;

//ncr (2D array) will contain the values of nCr  
unsigned int ncr[100][100];
// Preprcess to generate all nCr values using pascals triangle
void Gen_nCr() 
{ 
    ncr[0][0] = 1; 
    for (int i = 1; i < 60; i++) 
    { 
        ncr[i][0] = 1; 
        for (int j = 1; j < i + 1; j++) 
        { 
            ncr[i][j] = (ncr[i - 1][j - 1] + ncr[i - 1][j]); 
        } 
    } 
} 


class matrix
{
    public :
    int row;
    int col;
    unsigned int mat[60][60];
    matrix(int n,int m)
    {
        row=n;
        col=m;
        memset(mat,0,sizeof(mat));
    }
    
    void display(string s)
    {
        cout<<"Displaying Matrix ("<<s<<") of Row-"<<row<<"  Col-"<<col<<"\n";
        for(int i=0;i<col*2;i++)cout<<"-";cout<<"\n";
        for(int i=0;i<row;i++)
        {
            for(int j=0;j<col;j++)
            {
                cout<<mat[i][j]<<" ";
            }
            cout<<"\n";
        }
        for(int i=0;i<col*2;i++)cout<<"-";cout<<"\n\n\n";
    }
    
};

inline matrix identity(matrix A)
{
    matrix I(A.row,A.row);
    for(int i=0;i<A.row;i++)I.mat[i][i]=1;
    return I;
}

inline int identity(int a)
{
    return 1;
}

//multiplies two matrices
matrix mult(const matrix &a,const matrix &b)
{
    matrix res(a.row,b.col);
    for (int i = 0; i < a.row; i++) 
    {
        for (int j = 0; j < b.col; j++) 
        {
            for (int k = 0; k < a.col; k++) 
            {
                res.mat[i][j] =(res.mat[i][j] + ( a.mat[i][k] * b.mat[k][j] )  ) ;
            }
        }
    }
    return res;
}

unsigned int mult(unsigned int a,unsigned int b)
{
    return (a*b) ;
}


//Fast exponentiation (divide and conquer)--recursive approach
template <class T> T expo(T x, long long int y)
{
    if(y==0) return identity(x);
    if(y==1)return x;
    T res = expo(x, y/2);
    T ans = mult(res,res);
    return (y & 1) ? mult(ans,x) :  ans ; 
}


unsigned int solve(long long int n,int k)
{
    matrix A(k+2,k+2);
    matrix H(k+2,1);
    
    //initalizing Base matrix A and helper matrix H
    for(int i=0;i<k+2;i++)
    {
        if(i==0)
        {
            H.mat[i][0]=1;
            A.mat[i][0]=1;
            for(int j=1;j<k+2;j++)
            {
                int l = i+1;
                A.mat[i][j] = ncr[k-l+1][j-l];
            }
            
            continue;
        }
        
        H.mat[i][0]=1;
        for(int j=i;j<k+2;j++)
        {
            A.mat[i][j]=ncr[k-i+1][j-i];
        }
    }
    
    
    //A.display("x");
    
    //H.display("H");

    
    //mult(expo(A,n),H).display("res");
    
    return mult(expo(A,n-1),H).mat[0][0];
    
    
}


int main()
{
    Gen_nCr() ;
    int t=1;
    scanf("%lld",&t);
    
    for(int tc=1; tc<=t  ;tc++)
    {
        int k;
        long long int n;
        scanf("%lld%d",&n,&k);
        printf("Case %d: %lu\n",tc,solve(n,k));
    }
}












